#!/usr/bin/python

from sys import argv, stdin, stdout, stderr, exit
from subprocess import check_output, Popen
import os
import stat
import re
import git
from uuid import uuid1

from colorful import colorful

def cmp_issue(a, b):
  aa = os.lstat("%s/issue"%a)
  bb = os.lstat("%s/issue"%b)
  return aa.st_ctime < bb.st_ctime

class GitIssue:
  def __init__(self):
    self.git = git.Repo(".")

    self.issues="%s/.issues"%self.git.working_dir

  def cmd_ls(self, args):
    contents = [ self.issues + "/" + x for x in os.listdir(self.issues) if stat.S_ISDIR(os.lstat(self.issues + "/" + x).st_mode)]
    sorted(contents, cmp = cmp_issue)
    for issue in contents:
      self.show_short(issue)
    return True

  def cmd_show(self, args):
    if len(args) != 1:
      stderr.write("git issue show takes identifier as argument\n")
      return False

    key = args[0]
    issue_file = None
    for i in os.listdir(self.issues):
      issue = "%s/%s"%(self.issues, i)
      if not stat.S_ISDIR(os.lstat(issue).st_mode):
        continue
      if i.split('-')[0] == key or i == key:
        issue_file = "%s/issue"%issue
        break
    if not issue_file:
      stderr.write("git issue %s not found\n"%key)
      return False

    f = open(issue_file, 'r')
    blocks = f.read().split('\n\n')
    f.close()

    ident_short = self.get_ident_short(issue)
    title = self.get_title(blocks)
    length = len(ident_short) + len(title) + 2
    print ident_short, colorful.bold_white(title)
    print "=" * length
    print
    print '\n\n'.join(blocks)
    print
    return True


  def cmd_edit(self, args):
    if len(args) < 1:
      stderr.write("git issue edit takes one or more identifier as argument\n")
      return False

    if self.git.is_dirty():
      stderr.write("repo is dirty\n")
      return False

    issue_files = []
    for key in args:
      issue_file = None
      for i in os.listdir(self.issues):
        issue = "%s/%s"%(self.issues, i)
        if not stat.S_ISDIR(os.lstat(issue).st_mode):
          continue
        if i.split('-')[0] == key or i == key:
          issue_file = "%s/issue"%issue
          break
      if not issue_file:
        stder.write("git issue %s not found\n"%key)
        return False

      issue_files.append(issue_file)

    p = Popen( ["sensible-editor"] + issue_files )
    p.communicate( )
    p.wait()

    for issue_file in issue_files:
      blocks = self.read_issue(issue_file)
      if not blocks:
        continue
      title = self.get_title(blocks)
      self.git.index.add([issue_file])
      self.git.index.commit("issue updated: %s"%title)
    return True

  def cmd_create(self, args):
    if len(args) < 1:
      stderr.write("git issue create needs arguments\n")
      return False

    if self.git.is_dirty():
      stderr.write("repo is dirty\n")
      return False

    if args:
      title = " ".join(args)
    else:
      title = "issue title goes here"
    uuid = uuid1()
    issue_path = "%s/%s"%(self.issues, uuid)
    issue_file = "%s/issue"%issue_path
    os.mkdir(issue_path)
    fin = open("%s/template"%self.issues, "r")
    fout = open(issue_file, "w")
    for line in fin.readlines( ):
      if line == "@title@\n":
        line = "%s\n"%title
        line += ("=" * (len(title) + 1)) + "\n"
      fout.write(line)
    fin.close()
    fout.close()

    p = Popen( ["sensible-editor", issue_file])
    p.communicate( )
    p.wait()

    blocks = self.read_issue(issue_file)
    if not blocks:
      return False
    title = self.get_title(blocks)

    self.git.index.add([issue_file])
    self.git.index.commit("new issue: %s"%title)
    return True

  def cmd_remove(self, args):
    if len(args) != 1:
      stderr.write("git issue delete takes identifier as argument\n")
      return False

    key = args[0]
    issue_file = None
    for i in os.listdir(self.issues):
      issue_path = "%s/%s"%(self.issues, i)
      if not stat.S_ISDIR(os.lstat(issue_path).st_mode):
        continue
      if i.split('-')[0] == key or i == key:
        issue_file = "%s/issue"%issue_path
        break
    if not issue_file:
      stderr.write("git issue %s not found\n"%key)
      return False

    blocks = self.read_issue(issue_file)
    if blocks:
      title = self.get_title(blocks)
    else:
      title = "no title"

    stdout.write("remove issue %s: %s ? [Y/n] "%(key, title))
    try:
      answer = stdin.readline().strip()
    except KeyboardInterrupt:
      return False
    if not answer or answer.lower() == "y":
      from shutil import rmtree
      rmtree(issue_path)

      self.git.index.remove([issue_path], r = True)
      self.git.index.commit("issue removed: %s"%title)



  def read_issue(self, issue_file):
    if not os.path.exists(issue_file):
      stderr.write("issue file not found: %s\n"%issue_file)
      return None

    f = open(issue_file, 'r')
    blocks = f.read().split('\n\n')
    f.close()
    return blocks

  def show_short(self, issue):
    issue_file = "%s/issue"%issue
    blocks = self.read_issue(issue_file)
    if blocks:
      print self.get_ident_short(issue), colorful.bold_white(self.get_title(blocks))

  def get_ident(self, issue):
    return os.path.basename(issue)

  def get_ident_short(self, issue):
    return self.get_ident(issue).split('-')[0]

  def get_title(self, blocks):
    RE = re.compile(r'^.*?\n[=-]+[ ]*(\n|$)', re.MULTILINE)
    title = "no title"
    idx = 0
    for block in blocks:
      if RE.match(block):
        title = block.split('\n')[0].strip()
        blocks.pop(idx)
        break
      idx += 1
    return title

if __name__ == "__main__":
  cmd = "ls"
  if len(argv) > 1:
    cmd = argv[1]

  try:
    gi = GitIssue()
  except git.exc.InvalidGitRepositoryError:
    stderr.write("not a git repo\n")
    exit(1)
  if hasattr(gi, "cmd_%s"%cmd):
    if not getattr(gi, "cmd_%s"%cmd)(argv[2:]):
      exit( 1 )
    exit( 0 )
  else:
    stderr.write("unknown command: %s\n"%cmd)
    exit(2)



