#!/usr/bin/env python

from sys import argv, stdin, stdout, stderr, exit
from subprocess import check_output, Popen
import os
import stat
import re
import git
from uuid import uuid1

from colorful import colorful

def cmp_tessera(a, b):
  aa = os.lstat("%s/tessera"%a)
  bb = os.lstat("%s/tessera"%b)
  return aa.st_ctime < bb.st_ctime

class GitTessera:
  def __init__(self):
    self.git = git.Repo(".")

    self.tesserae="%s/.tesserae"%self.git.working_dir

  def cmd_ls(self, args):
    contents = [ self.tesserae + "/" + x for x in os.listdir(self.tesserae) if stat.S_ISDIR(os.lstat(self.tesserae + "/" + x).st_mode)]
    sorted(contents, cmp = cmp_tessera)
    for tessera in contents:
      self.show_short(tessera)
    return True

  def cmd_show(self, args):
    if len(args) != 1:
      stderr.write("git tessera show takes identifier as argument\n")
      return False

    key = args[0]
    tessera_file = None
    for i in os.listdir(self.tesserae):
      tessera = "%s/%s"%(self.tesserae, i)
      if not stat.S_ISDIR(os.lstat(tessera).st_mode):
        continue
      if i.split('-')[0] == key or i == key:
        tessera_file = "%s/tessera"%tessera
        break
    if not tessera_file:
      stderr.write("git tessera %s not found\n"%key)
      return False

    f = open(tessera_file, 'r')
    blocks = f.read().split('\n\n')
    f.close()

    ident_short = self.get_ident_short(tessera)
    title = self.get_title(blocks)
    length = len(ident_short) + len(title) + 2
    print "=" * length
    print ident_short, colorful.bold_white(title)
    print "=" * length
    print
    print '\n\n'.join(blocks)
    print
    return True


  def cmd_edit(self, args):
    if len(args) < 1:
      stderr.write("git tessera edit takes one or more identifier as argument\n")
      return False

    if self.git.is_dirty():
      stderr.write("repo is dirty\n")
      return False

    tessera_files = []
    for key in args:
      tessera_file = None
      for i in os.listdir(self.tesserae):
        tessera = "%s/%s"%(self.tesserae, i)
        if not stat.S_ISDIR(os.lstat(tessera).st_mode):
          continue
        if i.split('-')[0] == key or i == key:
          tessera_file = "%s/tessera"%tessera
          break
      if not tessera_file:
        stder.write("git tessera %s not found\n"%key)
        return False

      tessera_files.append(tessera_file)

    p = Popen( ["sensible-editor"] + tessera_files )
    p.communicate( )
    p.wait()

    for tessera_file in tessera_files:
      blocks = self.read_tessera(tessera_file)
      if not blocks:
        continue
      title = self.get_title(blocks)
      self.git.index.add([tessera_file])
      self.git.index.commit("tessera updated: %s"%title)
    return True

  def cmd_create(self, args):
    if len(args) < 1:
      stderr.write("git tessera create needs arguments\n")
      return False

    if self.git.is_dirty():
      stderr.write("repo is dirty\n")
      return False

    if args:
      title = " ".join(args)
    else:
      title = "tessera title goes here"
    uuid = uuid1()
    tessera_path = "%s/%s"%(self.tesserae, uuid)
    tessera_file = "%s/tessera"%tessera_path
    os.mkdir(tessera_path)
    fin = open("%s/template"%self.tesserae, "r")
    fout = open(tessera_file, "w")
    for line in fin.readlines( ):
      if line == "@title@\n":
        line = "%s\n"%title
        line += ("=" * (len(title) + 1)) + "\n"
      fout.write(line)
    fin.close()
    fout.close()

    p = Popen( ["sensible-editor", tessera_file])
    p.communicate( )
    p.wait()

    blocks = self.read_tessera(tessera_file)
    if not blocks:
      return False
    title = self.get_title(blocks)

    self.git.index.add([tessera_file])
    self.git.index.commit("new tessera: %s"%title)
    return True

  def cmd_remove(self, args):
    if len(args) != 1:
      stderr.write("git tessera delete takes identifier as argument\n")
      return False

    key = args[0]
    tessera_file = None
    for i in os.listdir(self.tesserae):
      tessera_path = "%s/%s"%(self.tesserae, i)
      if not stat.S_ISDIR(os.lstat(tessera_path).st_mode):
        continue
      if i.split('-')[0] == key or i == key:
        tessera_file = "%s/tessera"%tessera_path
        break
    if not tessera_file:
      stderr.write("git tessera %s not found\n"%key)
      return False

    blocks = self.read_tessera(tessera_file)
    if blocks:
      title = self.get_title(blocks)
    else:
      title = "no title"

    stdout.write("remove tessera %s: %s ? [Y/n] "%(key, title))
    try:
      answer = stdin.readline().strip()
    except KeyboardInterrupt:
      return False
    if not answer or answer.lower() == "y":
      from shutil import rmtree
      rmtree(tessera_path)

      self.git.index.remove([tessera_path], r = True)
      self.git.index.commit("tessera removed: %s"%title)



  def read_tessera(self, tessera_file):
    if not os.path.exists(tessera_file):
      stderr.write("tessera file not found: %s\n"%tessera_file)
      return None

    f = open(tessera_file, 'r')
    blocks = f.read().split('\n\n')
    f.close()
    return blocks

  def show_short(self, tessera):
    tessera_file = "%s/tessera"%tessera
    blocks = self.read_tessera(tessera_file)
    if blocks:
      print self.get_ident_short(tessera), colorful.bold_white(self.get_title(blocks))

  def get_ident(self, tessera):
    return os.path.basename(tessera)

  def get_ident_short(self, tessera):
    return self.get_ident(tessera).split('-')[0]

  def get_title(self, blocks):
    RE = re.compile(r'^.*?\n[=-]+[ ]*(\n|$)', re.MULTILINE)
    title = "no title"
    idx = 0
    for block in blocks:
      if RE.match(block):
        title = block.split('\n')[0].strip()
        blocks.pop(idx)
        break
      idx += 1
    return title

if __name__ == "__main__":
  cmd = "ls"
  if len(argv) > 1:
    cmd = argv[1]

  try:
    gi = GitTessera()
  except git.exc.InvalidGitRepositoryError:
    stderr.write("not a git repo\n")
    exit(1)
  if hasattr(gi, "cmd_%s"%cmd):
    if not getattr(gi, "cmd_%s"%cmd)(argv[2:]):
      exit( 1 )
    exit( 0 )
  else:
    stderr.write("unknown command: %s\n"%cmd)
    exit(2)



